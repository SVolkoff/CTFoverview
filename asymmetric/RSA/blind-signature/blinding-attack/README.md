# Blind

#### VolgaCTF 2019

### Условия задания

Задание содержит ip/порт сервера CTF, на котором выполняется задание, а также скрипт [server.py](server.py), который запускается на сервере.

Требуется извлечь флаг, находящийся на сервере.

### Уязвимость
Исходный код сервера дан в условии. Его принцип работы заключается в следующем:
Читается строка из `stdin`, после чего разбивается на слова: первое слово записывается в `sgn`, а все остальные слова в `cmd_exp`.
 Затем функция `shlex.split(cmd_exp)` разбивает строку `cmd_exp`. Первый элемент результата записывается в `cmd`: 

В зависимости от значения `cmd` выполняется один из нескольких блоков `if`. Если cmd имеет значение `ls` или `dir`, команда, хранящаяся в `cmd_exp`,
 выполняется сразу, независимо от значения `sgn`.

При других значениях `cmd` проверяется значение `sgn`. Переменная sgn передается в функцию `signature.verify(...)` вместе с переменной `cmd_exp`, 
где проверяется, является ли `sgn` RSA - подписью команды `cmd_exp`. Если функция возвращает `false`, команда не выполняется. 

Простая RSA - подпись сообщения реализована в классе RSA. Для того, чтобы сообщение получило подпись, оно преобразуется в целое число и возводится в степень d по модулю n.  Для проверки подписи сообщения, оно возводится в степень e по модулю n, а затем сравнивается с исходным сообщением. Если их значения совпадают, подпись проходит проверку. Открытый ключ n и открытая экспонента e написаны в исходном коде задачи, поэтому их значения известны. 

Для получения флага нужно запустить `cat flag`, но если команда содержит `cat` или `cd`, то она подписываться сервером не будет.

В этом случае можно реализовать стандартный [алгоритм слепой подписи](Chaum.BlindSigForPayment1982.pdf), идея которого заключается в следующем:
-	Берется некоторое число `r`, взаимно простое с n и вычисляется `m’= m*r^e mod n`, где `m` -сообщение, которое требуется подписать;
-	Полученный результат отправляется на сервер для получения подписи;
-	Мы используем `r` для расчета подписи исходного сообщения от подписи, которую мы получили;
-	Сервер вычисляет и возвращает подпись для сообщения `m’`: `s’= m’^d mod n`;
-	Из подписи `s’` можно получить подпись `s` для исходного сообщения: `s = s’*r^-1 mod n`.

Сообщение, подписываемое сервером, перед подписью передается функции `shlex.split(...)`, из-за чего требуется подобрать такое `r`,
 чтобы измененное сообщение не разделялось `shlex.split(...)`.  
Т.к. на `r` накладывается только условие взаимной простоты с `n`, которое является произведением двух больших простых чисел, то можно 
просто перебрать различные значения `r` и проверить совпадет ли измененное сообщение и возвращаемое `shlex.split(...)` значение. 

После получения `r = 6631`, можно применить алгоритм слепой подписи к `cat flag` для извлечения флага. 

Подбирает `r`: [getfactor.py](getfactor.py)
Получает флаг: [solve.py](solve.py)
