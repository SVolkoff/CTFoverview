# Request-Auth

#### InCTFi-2018

### Условия задания

В задаче даны файлы: [iv.txt](iv.txt), [key.enc](key.enc), [publickey.pem](publickey.pem), [ServerSide.py](ServerSide.py),
 [session.enc](session.enc), а также ip/порт сервера CTF, на котором выполняется задание.
Нужно найти флаг, содержащийся в файле [session.enc](session.enc).

### Уязвимость
Исходный код сервера дан в условии. Его принцип работы заключается в следующем: 
Для аутентификации запросов сеанса, поступающих от пользователя, используется комбинация RSA и AES.

Для каждого нового сеанса клиент генерирует новый действительный запрос 
req, который шифруется в режиме AES-CBC, с использованием 16-байтного ключа `k` и 16-байтного вектора 
инициализации(IV): `session_enc  = E_AES(req)`.
Затем клиент шифрует 16- байтный ключ AES `k`, используя открытый ключ сервера `e`: `key_enc = k^e mod n`, и передает зашифрованный 
сеанс `session_enc` и зашифрованный ключ сеанса `key_enc` в качестве данных для входа на сервер.
После получения `session_enc` и `key_enc` от клиента, сервер расшифровывает `key_enc`, используя свой закрытый ключ `d`: `k= key_enc^d mod n`, и 
сохраняет 16 младших байтов получившегося значения `k` в качестве ключа.
Затем расшифровывает session_enc, используя значение ключа `k`: `req = D_AES(session_enc)`, и проверяет правильность результирующего запроса с помощью функции
 `check_valid_request()`, которая возвращает true, если запрос действителен и false в противном случае.

Т.к. сервер сообщает только действителен ли запрос, то напрямую получить флаг от сервера не получится.  
Поэтому нужно найти ключ AES, с помощью которого шифруется `session.enc`. 

Т.к. зашифрованный ключ AES контролируется пользователем, можно выполнить [атаку на основе подобранного шифртекста](1802.03367.pdf). 

Известно, что: `key_enc = k^e mod n`.

Если умножить `key_enc` на  `2^me mod n`, получим:

`key_enc * 2^me mod n = k^e * 2^me  mod n`

`key_enc * 2^me mod n =(k * 2^m)^e  mod n`

Так, зная только зашифрованный текст `k`, можно генерировать значения шифртекстов: `2k`, `4k`, `8k`, ... и т. д. Также известно, что независимо 
от размера зашифрованного текста `k`, после его дешифрования сервер сохранит только 16 младших байт.

Будем обозначать `key_enc_m` =  `key_enc * 2^m mod n`  и   `k_m =  k * 2^m mod n`.
`key_enc_127` является зашифрованным значением `k_127`, в котором каждый бит, кроме самого старшего, равен нулю, а старший бит `k_127` будет
 являться младшим битом `k`, т.к. после отправки `key_enc_127` на сервер и дешифрования, в качестве ключа для дешифрования сеанса сохранятся 
 только 16 младших байтов `k`. 
 
Предположим, что старший бит `k_127` равен нулю, зашифруем сеанс ключом, у которого младший значащий бит равен 0 и отправим его на сервер.

Если сервер отвечает, что ответ действителен, то младший значащий бит ключа AES равен 0, в противном случае он равен 1. Затем отправляем 
`key_enc_126`, который является зашифрованным значением `k_126`, зашифровываем действительный сеанс ключом, в котором 0 - 125 биты равны нулю,
 127 бит равен нулю, а 126 бит является младшим битом `k`, полученным от предыдущей итерации. И снова, если сервер отвечает, что запрос
 действителен, то второй младший бит ключа AES равен 0, в противном случае он равен 1.
 
Данная процедура повторяется для `key_enc_125`, `key_enc_124`,…, `key_enc_0`, пока все биты `k` не будут получены. 

Решение: [exploit.py](exploit.py)
