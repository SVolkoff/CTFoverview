# mixed cipher

#### TokyoWesterns CTF - 2018 

### Условия задания

Дан порт сервера, на котором выполняется задание, а также скрипт python [server.py](server.py), который запускается на сервере:
Требуется получить флаг, находящийся на сервере.

### Уязвимость

В задании дан исходный код сервера, который предоставляет 4 функции:
-	`encrypt` - зашифровывает данные, предоставленные пользователем, с помощью AES-CBC (каждый раз со случайным вектором инициализации(IV)) и RSA, и возвращает результат шифрования.
-	`decrypt` - выполняет дешифрование RSA и возвращает только последний байт результата.
-	`get encrypted flag` - возвращает зашифрованный с помощью AES-CBC флаг, но IV при этом остается неизвестным.
-	`get encrypted key` - возвращает ключ для AES, зашифрованный с помощью RSA.

Для AES известно, что `key` генерируется с помощью `os.urandom(16)`, и что шифрование использует режим CBC со случайным вектором 
инициализации, который генерируется с помощью `random.getrandbits(128)`.
Чтобы получить IV для `get encrypted flag`, нужно найти внутреннее состояние генератора псевдослучайных чисел. Т.к. библиотека random
 в python является реализацией Mersenne Twister, используем инструмент [randcrack](randcrack.py).
Для получения внутреннего состояния нужно только 156 запросов. 

Для RSA известно значение `e = 65537`, так как это стандартное значение `e` при использовании `RSA.generate()`, и известно, что длина `n` составляет `1024` бита. 
Чтобы получить key с помощью [LSB - оракула RSA](25670324.pdf), можно выполнить бинарный поиск и после 1024 запросов на сервер получить значение `key`, но это приведет к тайм-ауту, 
потому что соединение закрывается через 300 секунд (`signal.alarm(300)`). Но из исходного кода известно, что длина `key` составляет 128 бит,
 так что первые 896 итераций поиска всегда будут возвращать четный бит, и, следовательно данную атаку можно оптимизировать, имитировав первые 896 итераций без связи с сервером, 
 также потому что последний байт `key` известен можно получить `key`, когда зашифрованными остается меньше 256 бит. Всего выходит около 120 запросов на сервер. 

Чтобы выполнить LSB-атаку, нужно узнать `n` для RSA. Т.к. `c = m^e mod n` что эквивалентно тому, что `m^e - c = n*k`, то получив несколько значений с помощью оракула шифрования RSA, можно восстановить `n`.  
Т.о. отправив на сервер некоторое значение `a`, получим назад число `c1` такое, что `c1 = a^e mod n`. Это означает, что `a^e - c1 = k1*n` для некоторого значения `k1`. 
Так же можно получить другое значение `c2` с сервера, на этот раз для некоторого `b`, и таким образом получим из `b^e - c2 = k2*n` другое `k2`. Таким образом получаем разные
 значения `k`, назовем их `ki`. Значений нужно найти столько, чтобы НОД всех `ki` являлся 1024-битным числом. Это и будет значение `n`. На это потребуется 2-4 запроса.  

Таким образом, всего потребовалось примерно 280 запросов, что достаточно для времени соединения.

Решение: [solve.py](solve.py).

